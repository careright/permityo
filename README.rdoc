<i>This Rails 3 engine is a highly modified fork of the excellent authorization plugin by Bill Katz, which I've used fondly for years.</i>

= Constellation Authorization

This engine provides a flexible way to add authorization to Rails 3 applications.

The authorization process decides whether a user is allowed access to some
feature.  It is distinct from the authentication process, which tries to
confirm a user is authentic, not an imposter. There are many authentication
systems available for Rails, e.g., restful_authentication and Authlogic. This
authorization system will play nicely with them as long as some simple
requirements are met:

1. User objects are available that implement a has_role?(role,
   authorizable_object = nil) method. This requirement can be easily
   handled by using acts_as_authorized_user in the User-like class.

2. If you want to use "role of model" authorization expressions, like "owner of
   resource" or "eligible for :award", then your models with roles must
   implement an accepts_role?(role, user) method. This requirement can
   be handled by using acts_as_authorizable in the model class.

The authorization plugin provides the following:

* A simple way of checking authorization at either the class or instance method
  level using #permit and #permit?

* Authorization based on the relationships already in your application's model tier.

* If you wish for different behavior, you can override the has_role? and accepts_role? methods
  by yourself or by using another gem that provides them (although there are none as of this writing).

== Example Usage

  class MeetingController < ApplicationController

    permit "rubyists and wanna_be_rubyists", :except => :public_page

    def public_page
      render :text => "We're all in Chicago"
    end

    def secret_info
      permit "interested in Answers and (matz or dhh)" do
        render :text => "The Answer = 42"
      end
    end

    def find_apprentice
      @founder = User.find_by_name('matz')
      permit "'inner circle' of :founder" do
        if request.post?
          apprentice = User.find_by_skillset(params[:uber_hacker])
          ruby_community = Group.find_by_name('Ruby')
          ruby_community.accepts_role 'yarv_builder', apprentice
        end
      end
    end

    def rails_conf
      @meeting = Meeting.find_by_name('RailsConf')
      permit "attendees of :meeting or swedish_mensa_supermodels" do
        venue = Hotel.find_by_name("Wyndham O'Hare")
        current_user.is_traveller_to venue
        if permit? "traveller to :venue and not speaker"
          Partay.all_night_long
          @misdeeds = current_user.is_participant_in_what
        end
      end
    end

  end


== Installation

In your Gemfile:
  
  gem "constellation-authorization"

== Configuration

To use the default implementation, simply call +acts_as_authorized_user+ from your User model, and +acts_as_authorizable+ from
any model you wish to be authorizable.

To use a custom implementation, simply define <tt>has_role?(role)</tt> on your user and <tt>accepts_role?(role, user)</tt> on the relevant models. It is possible for another gem to provide alternate implementations for you, but none currently exist.

To change the settings, in the config block of your application, you can change the following settings from their defaults below.

* <tt>config.constellation.authorization.implementation = :default</tt>
* <tt>config.constellation.authorization.login_required_redirection = { :controller => 'user_sessions', :action => 'new' }</tt>
* <tt>config.constellation.authorization.permission_denied_redirection = ''</tt>
* <tt>config.constellation.authorization.store_location_method = :store_location</tt>
* <tt>config.constellation.authorization.current_user_method = :current_user</tt>

=== Jumpstarting with the default

Now we need to add the methods needed by each of your models that will
participate in role based authorization. Typically these models fall into
two categories, the User model, and all other models that will have
roles available for use.

For a typical installation you would add both mixins to your User model.

  class User < ActiveRecord::Base

    # Authorization plugin
    acts_as_authorized_user
    acts_as_authorizable

  ...

Then in each additional model that you want to be able to restrict based
on role you would add just the acts_as_authorizable mixin like this:

  class Event < ActiveRecord::Base

    acts_as_authorizable

  ...

You are done with the configuration!

== The Specifics

=== permit and permit?

permit and permit? take an authorization expression and a hash of options that
typically includes any objects that need to be queried:

  permit <authorization expression> [, options hash ]
  permit? <authorization expression> [, options hash ]

The difference between permit and permit? is redirection. permit is a
declarative statement and redirects by default. It can also be used as a class
or an instance method, gating the access to an entire controller in a
before_filter fashion.

permit? is only an instance method, can be used within expressions, does not
redirect by default.

The authorization expression is a boolean expression made up of permitted
roles, prepositions, and authorizable models. Examples include "admin" (User
model assumed), "moderator of :workshop" (looks at options hash and then
@workshop), "'top salesman' at :company" (multiword roles delimited by single
quotes), or "scheduled for Exam" (queries class method of Exam).

Note that we can use several permitted prepositions ('of', 'for', 'in', 'on',
'to', 'at', 'by'). In the discussion below, we assume you use the "of"
preposition. You can modify the permitted prepositions by changing the constant
in Authorization::Base::Parser.

* If a specified role has no "of <model>" designation, we assume it is a user
  role (i.e., the model is the user-like object).

* If an "of model" designation is given but no "model" key/value is supplied in
  the hash, we check if an instance variable @model if it's available.

* If the model is capitalized, we assume it's a class and query
  <tt>Model#self.accepts_role?</tt> (the class method) for the
  permission. (Currently only available in ObjectRolesTable mixin.)

For each role, a query is sent to the appropriate model object.

The grammar for the authorization expression is:

         <expr> ::= (<expr>) | not <expr> | <term> or <expr> | <term> and <expr> | <term>
         <term> ::= <role> | <role> <preposition> <model>
  <preposition> ::= of | for | in | on | to | at | by
        <model> ::= /:*\w+/
         <role> ::= /\w+/ | /'.*'/

Parentheses should be used to clarify permissions. Note that you may prefix the
model with an optional ":" -- the first versions of Authorization plugin made
this mandatory but it's now optional since the mandatory preposition makes
models unambiguous.

==== Options

  :allow_guests => false.

We can allow permission processing without a
current user object. The default is false.

  :user => YourUserObject.

The name of your user object.

  :get_user_method => method_name

The method name provided should return a user
object. Default is #current_user, which is the how
acts_as_authenticated works.

  :only => [ :method1, :method2 ]

Array of methods to apply permit (not valid when used in instance methods)

  :except => [ :method1, :method2 ]

Array of methods that won't have permission checking (not valid when used in instance methods)

  :redirect => boolean

Default is true. If false, permit will not redirect to denied page.

  :login_required_redirection => path or hash

  default is "{ :controller => 'session', :action => 'new' }"

Path or Hash where user will be redirected if not logged in ()

  :login_required_message => 'my message'

A string to present to your users when login is required. Default is 'Login is required to access the requested page.'

  :permission_denied_redirection => path or hash

Path or Hash where user will be redirected if logged in but not authorized (default is '')

  :permission_denied_message => 'my message'

Message that will be presented to the user when permission is denied.  Default is 'Permission
denied. You cannot access the requested page.'

=== Pattern of use

We expect the application to provide the following methods:

==== #current_user (configurable)

Returns some user object, like an instance of my favorite class,
<tt>UserFromMars</tt>.  A <tt>user</tt> object, from the Authorization
viewpoint, is simply an object that provides a <tt>has_role?</tt> method.

Note that duck typing means we don't care what else the <tt>UserFromMars</tt>
might be doing.  We only care that we can get an id from whatever it is, and we
can check if a given role string is associated with it. By using
<tt>acts_as_authorized_user</tt>, we inject what we need into the user object.

If you use an authorization expression "admin of :foo", we check permission by
asking <tt>foo</tt> if it <tt>accepts_role?('admin', user)</tt>. So for each
model that is used in an expression, we assume that it provides the
<tt>accepts_role?(role, user)</tt> method.

Note that <tt>user</tt> can be <tt>nil</tt> if <tt>:allow_guests => true</tt>.

==== #store_location (optional, configurable)

This method will be called if authorization fails and the user is about to be
redirected to the login action. This allows the application to return to the
desired page after login.  If the application doesn't provide this method, the
method will not be called.

The name of the method for storing a location can be modified by changing the
constant STORE_LOCATION_METHOD in environment.rb. Also, the default login and
permission denied pages are defined by the constants LOGIN_REQUIRED_REDIRECTION
and PERMISSION_DENIED_REDIRECTION in authorization.rb and can be overriden in
your environment.rb.

=== Conventions

Roles specified without the "of model" designation:

1. We see if there is a <tt>current_user</tt> method available that will return
   a user object. This method can be overridden with the <tt>:user</tt> hash.

2. Once a user object is determined, we pass the role to
   <tt>user.has_role?</tt> and expect a true return value if the user has the
   given role.

Roles specified with "of model" designation:

1. We attempt to query an object in the options hash that has a matching
   key. Example: <tt>permit "knight for justice", :justice =>
   @abstract_idea</tt>

2. If there is no object with a matching key, we see if there's a matching
   instance variable. Example: @meeting defined before we use <tt>permit
   "moderator of meeting"</tt>

3. Once the model object is determined, we pass the role and user (determined
   in the manner above) to <tt>model.accepts_role?</tt>